package jvm.bytecode;

/**
 * 现代JVM在执行代码的时候,通常都会将解释执行与编译执行二者结合起来使用.
 *
 * 所谓解释执行,就是通过解释器来读取字节码,遇到相应的指令就执行该指令.
 * 所谓编译执行,就是通过即时编译器(Just It Time)将字节码转换为本地机器码来执行,
 *      现代JVM会根据代码热点(需要频繁执行的代码)来生成相应的本地机器码.
 *
 * 基于栈的指令集与基于寄存器的指令集之间的关系.
 * 1,JVM执行指令时所采取的方式时基于栈的指令集
 * 2,基于栈的指令集主要操作入栈和出栈两种
 * 3,基于栈指令集的优点在于它可以在不同平台之间移植,而基于寄存器指令集是与硬件相关联的,无法做到可移植
 * 4,基于栈指令集的缺点在于,需要完成相同的操作,指令数量通常要比基于寄存器的指令集要多很多;
 *      基于栈的指令集是在内存中完成操作的,而基于寄存器的指令集是直接由cpu来执行的,
 *      它是在高速缓冲区中进行执行的,速度快很多,虽然虚拟机可以采用一些优化手段,(根据代码热点生成本机机器码)
 *      但总体来说,栈的指令集执行起来速度会慢很多.
 *
 */
public class MyTest8 {

    public int myCalculate(){
        int a = 1;
        int b = 2;
        int c = 3;
        int d = 4;
        int result = (a + b - c) * d;
        return result;
        /**
         * myCalculate方法的字节码分析
         *  0 iconst_1  将值为1的int类型数据压入操作数栈
         *  1 istore_1  将操作数栈顶的int类型的值弹出,将值存储到局部变量表中索引为1的变量.
         *  2 iconst_2
         *  3 istore_2
         *  4 iconst_3
         *  5 istore_3
         *  6 iconst_4
         *  7 istore 4
         *  9 iload_1   从局部变量表中索引为1的变量中加载int类型的值
         * 10 iload_2   从局部变量表中索引为2的变量中加载int类型的值
         * 11 iadd      将操作数栈中栈顶的两个元素弹出后相加,并将结果压入到操作数栈栈顶
         * 12 iload_3
         * 13 isub      将操作数栈的栈顶两个元素弹出后相减,并将结果值压入到操作数栈的栈顶
         * 14 iload 4
         * 16 imul      将操作数栈的两个元素弹出后相乘,并将结果压入操作数栈中.
         * 17 istore 5  将操作数栈顶的int类型的值弹出,将值存储到局部变量表中索引为5的变量.
         * 19 iload 5   从局部变量表中索引为5的变量中加载int类型的值
         * 21 ireturn   将int类型的值返回
         */
    }
}
